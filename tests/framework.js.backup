/**
 * æµ‹è¯•æ¡†æ¶é…ç½®
 * ä½¿ç”¨åŸç”Ÿ JS å®ç°ç®€å•çš„æµ‹è¯•æ¡†æ¶
 */

class TestRunner {
  constructor() {
    this.tests = [];
    this.results = {
      passed: 0,
      failed: 0,
      skipped: 0
    };
    this.beforeEachHooks = [];
  }

  describe(name, fn) {
    const beforeEachHooksBackup = [...this.beforeEachHooks];
    this.beforeEachHooks = [];

    console.group(`ğŸ“¦ ${name}`);
    fn(this);
    console.groupEnd();

    this.beforeEachHooks = beforeEachHooksBackup;
  }

  beforeEach(fn) {
    this.beforeEachHooks.push(fn);
  }

  runBeforeEachHooks() {
    this.beforeEachHooks.forEach(hook => hook());
  }

  it(name, fn) {
    try {
      this.runBeforeEachHooks();
      fn();
      this.results.passed++;
      console.log(`âœ… ${name}`);
    } catch (error) {
      this.results.failed++;
      console.error(`âŒ ${name}`);
      console.error(`   ${error.message}`);
    }
  }

  expect(actual) {
    return {
      toBe: (expected) => {
        if (actual !== expected) {
          throw new Error(`Expected ${expected}, but got ${actual}`);
        }
      },
      toBeInstanceOf: (expected) => {
        if (!(actual instanceof expected)) {
          throw new Error(`Expected instanceof ${expected.name}, but got ${typeof actual}`);
        }
      },
      toEqual: (expected) => {
        if (JSON.stringify(actual) !== JSON.stringify(expected)) {
          throw new Error(`Expected ${JSON.stringify(expected)}, but got ${JSON.stringify(actual)}`);
        }
      },
      toBeTruthy: () => {
        if (!actual) {
          throw new Error(`Expected truthy value, but got ${actual}`);
        }
      },
      toBeFalsy: () => {
        if (actual) {
          throw new Error(`Expected falsy value, but got ${actual}`);
        }
      },
      toBeLessThan: (expected) => {
        if (!(actual < expected)) {
          throw new Error(`Expected value less than ${expected}, but got ${actual}`);
        }
      },
      toThrow: () => {
        let threw = false;
        try {
          actual();
        } catch (e) {
          threw = true;
        }
        if (!threw) {
          throw new Error('Expected function to throw');
        }
      },
      not: {
        toThrow: () => {
          let threw = false;
          try {
            actual();
          } catch (e) {
            threw = true;
          }
          if (threw) {
            throw new Error('Expected function not to throw, but it did');
          }
        }
      }
    };
  }

  summary() {
    console.log('\nğŸ“Š æµ‹è¯•ç»“æœ:');
    console.log(`âœ… é€šè¿‡: ${this.results.passed}`);
    console.log(`âŒ å¤±è´¥: ${this.results.failed}`);
    console.log(`â­ï¸  è·³è¿‡: ${this.results.skipped}`);
    console.log(`ğŸ“ˆ æ€»è®¡: ${this.results.passed + this.results.failed + this.results.skipped}`);
    return this.results.failed === 0;
  }
}

// å¯¼å‡ºä¾›æµ‹è¯•æ–‡ä»¶ä½¿ç”¨
export default TestRunner;